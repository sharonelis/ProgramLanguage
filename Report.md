
# Custom Language Interpreter Project Report

## Introduction

This project report provides an overview of the design, challenges, and solutions involved in building a custom language interpreter using the following components: `Interpreter.py`, `Lexer.py`, `Parser.py`, `REPL.py`, and several test files for validating the functionality. The goal of this interpreter is to support a variety of programming constructs, including lambda expressions, function calls, and basic arithmetic and logical operations.

## Design Decisions

### Components Overview

1. **Interpreter.py**:
   - This file contains the core interpreter logic. It traverses the abstract syntax tree (AST) generated by the parser and evaluates expressions such as arithmetic operations, boolean logic, function definitions, and calls. The interpreter is designed to handle recursive calls, closures, and lambda expressions efficiently.

2. **Lexer.py**:
   - The lexer is responsible for breaking down the input code into tokens. It reads the source code character by character and identifies key language components such as identifiers, numbers, operators, and keywords (`def`, `if`, `else`, etc.). These tokens are passed to the parser for further analysis.

3. **Parser.py**:
   - The parser takes the tokens generated by the lexer and constructs an Abstract Syntax Tree (AST). The parser ensures that the code follows the grammatical structure defined for the language. It handles complex expressions such as conditional statements (`if-else`), function definitions, and lambda expressions.

4. **REPL.py**:
   - The REPL (Read-Eval-Print Loop) provides an interactive environment where users can execute statements one at a time. It uses the lexer, parser, and interpreter to process input and return results in real-time, making it ideal for testing and debugging.

5. **Test.Lambda**:
   - This file includes test cases for verifying the functionality of lambda expressions. It ensures that lambda expressions are properly parsed, evaluated, and used in higher-order functions within the interpreter.

6. **TestInterperter.py**:
   - Contains test cases that validate the overall functionality of the interpreter. The tests include basic arithmetic, boolean logic, and function evaluation to ensure that the interpreter behaves as expected.

7. **TestLexer.py**:
   - Contains test cases for the lexer. These tests ensure that the input code is correctly tokenized, and all language components are identified properly.

8. **TestParser.py**:
   - Contains test cases for the parser. These tests verify that the AST is correctly generated from the input tokens and that syntax errors are caught and reported appropriately.

9. **TestSuit.py**:
   - A comprehensive test suite that integrates all the test files (`Test.Lambda`, `TestInterperter.py`, `TestLexer.py`, and `TestParser.py`). It validates the overall performance and correctness of the language interpreter by running various edge cases and scenarios.

## Challenges Faced


### 1. Parsing and Evaluating Lambda Expressions
   - **Challenge**: Lambda expressions needed to be parsed and evaluated correctly, especially when used as higher-order functions.
   - **Solution**: The parser and interpreter were designed to handle anonymous functions and maintain the correct scope for each lambda expression.

### 2. Efficient Tokenization in the Lexer
   - **Challenge**: The lexer needed to tokenize the input efficiently without missing or misinterpreting characters.
   - **Solution**: A regular expression-based approach was used to identify tokens, ensuring that the lexer works reliably under different conditions.

## Solutions Implemented

### 1. Lexer and Parser
   - The lexer breaks the input code into tokens, and the parser constructs an AST. This ensures that the interpreter can accurately process both simple and complex expressions.

### 2. Interpreter
   - The interpreter traverses the AST and evaluates expressions, handling arithmetic operations, boolean logic, function calls, and lambdas. It supports recursion and nested function calls.

### 3. Test Suite
   - A full test suite (`TestSuit.py`) was developed to verify the functionality of each component in isolation and in integration. The tests cover edge cases and common use cases, ensuring the interpreter behaves as expected.

## Conclusion

The custom language interpreter project successfully implemented a functional programming language with robust features, including lambda expressions, function calls, recursion, and conditional logic. Despite facing challenges such as managing recursive calls and efficiently parsing complex expressions, the project delivered a working interpreter that can handle interactive REPL sessions and complete program executions from files. The comprehensive test suite ensures the reliability and robustness of the interpreter, confirming its ability to handle a wide variety of programming scenarios and edge cases. The project showcases the effectiveness of combining lexer, parser, and interpreter components to create a fully functional language processing system.
